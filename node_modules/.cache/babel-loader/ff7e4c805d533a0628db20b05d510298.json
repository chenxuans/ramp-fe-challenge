{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useCallback, useState, useEffect } from \"react\";\nimport { useCustomFetch } from \"./useCustomFetch\";\nexport function useEmployees() {\n  _s();\n\n  const {\n    fetchWithCache\n  } = useCustomFetch();\n  const [employees, setEmployees] = useState(null); // Introduce a separate loading state for employees to manage its loading status independently\n\n  const [isLoading, setIsLoading] = useState(false);\n  const fetchAll = useCallback(async () => {\n    setIsLoading(true); // Set the loading state to true when starting to fetch employee data\n\n    const employeesData = await fetchWithCache(\"employees\");\n    setEmployees(employeesData);\n    setIsLoading(false); // Reset the loading state to false after fetching employee data\n  }, [fetchWithCache]);\n  const invalidateData = useCallback(() => {\n    setEmployees(null); // Function to invalidate or reset employee data\n  }, []); // Use useEffect to fetch employee data when the component mounts or invalidateData is called\n  // This ensures that employee data is fetched once and only refetched when explicitly invalidated\n\n  useEffect(() => {\n    fetchAll();\n  }, [fetchAll]);\n  return {\n    data: employees,\n    loading: isLoading,\n    fetchAll,\n    invalidateData\n  };\n}\n\n_s(useEmployees, \"yz357v3sjspvc5ysbcUsTpRQjWw=\", false, function () {\n  return [useCustomFetch];\n});","map":{"version":3,"names":["useCallback","useState","useEffect","useCustomFetch","useEmployees","fetchWithCache","employees","setEmployees","isLoading","setIsLoading","fetchAll","employeesData","invalidateData","data","loading"],"sources":["/Users/chenxuansun/Desktop/ramp-fe-challenge/src/hooks/useEmployees.ts"],"sourcesContent":["import { useCallback, useState, useEffect } from \"react\";\nimport { Employee } from \"../utils/types\";\nimport { useCustomFetch } from \"./useCustomFetch\";\nimport { EmployeeResult } from \"./types\";\n\nexport function useEmployees(): EmployeeResult {\n  const { fetchWithCache } = useCustomFetch();\n  const [employees, setEmployees] = useState<Employee[] | null>(null);\n  // Introduce a separate loading state for employees to manage its loading status independently\n  const [isLoading, setIsLoading] = useState(false);\n\n  const fetchAll = useCallback(async () => {\n    setIsLoading(true); // Set the loading state to true when starting to fetch employee data\n    const employeesData = await fetchWithCache<Employee[]>(\"employees\");\n    setEmployees(employeesData);\n    setIsLoading(false); // Reset the loading state to false after fetching employee data\n  }, [fetchWithCache]);\n\n  const invalidateData = useCallback(() => {\n    setEmployees(null); // Function to invalidate or reset employee data\n  }, []);\n\n  // Use useEffect to fetch employee data when the component mounts or invalidateData is called\n  // This ensures that employee data is fetched once and only refetched when explicitly invalidated\n  useEffect(() => {\n    fetchAll();\n  }, [fetchAll]);\n\n  return { data: employees, loading: isLoading, fetchAll, invalidateData };\n}\n"],"mappings":";;AAAA,SAASA,WAAT,EAAsBC,QAAtB,EAAgCC,SAAhC,QAAiD,OAAjD;AAEA,SAASC,cAAT,QAA+B,kBAA/B;AAGA,OAAO,SAASC,YAAT,GAAwC;EAAA;;EAC7C,MAAM;IAAEC;EAAF,IAAqBF,cAAc,EAAzC;EACA,MAAM,CAACG,SAAD,EAAYC,YAAZ,IAA4BN,QAAQ,CAAoB,IAApB,CAA1C,CAF6C,CAG7C;;EACA,MAAM,CAACO,SAAD,EAAYC,YAAZ,IAA4BR,QAAQ,CAAC,KAAD,CAA1C;EAEA,MAAMS,QAAQ,GAAGV,WAAW,CAAC,YAAY;IACvCS,YAAY,CAAC,IAAD,CAAZ,CADuC,CACnB;;IACpB,MAAME,aAAa,GAAG,MAAMN,cAAc,CAAa,WAAb,CAA1C;IACAE,YAAY,CAACI,aAAD,CAAZ;IACAF,YAAY,CAAC,KAAD,CAAZ,CAJuC,CAIlB;EACtB,CAL2B,EAKzB,CAACJ,cAAD,CALyB,CAA5B;EAOA,MAAMO,cAAc,GAAGZ,WAAW,CAAC,MAAM;IACvCO,YAAY,CAAC,IAAD,CAAZ,CADuC,CACnB;EACrB,CAFiC,EAE/B,EAF+B,CAAlC,CAb6C,CAiB7C;EACA;;EACAL,SAAS,CAAC,MAAM;IACdQ,QAAQ;EACT,CAFQ,EAEN,CAACA,QAAD,CAFM,CAAT;EAIA,OAAO;IAAEG,IAAI,EAAEP,SAAR;IAAmBQ,OAAO,EAAEN,SAA5B;IAAuCE,QAAvC;IAAiDE;EAAjD,CAAP;AACD;;GAxBeR,Y;UACaD,c"},"metadata":{},"sourceType":"module"}